<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Task Manager - C++ Code</title>
    <style>
        body {
            font-family: monospace;
            background-color: #f5f5f5;
            padding: 20px;
        }
        pre {
            background-color: #2e3440;
            color: #d8dee9;
            padding: 15px;
            border-radius: 8px;
            overflow-x: auto;
        }
        .keyword { color: #81a1c1; font-weight: bold; }
        .string { color: #a3be8c; }
        .comment { color: #616e88; font-style: italic; }
    </style>
</head>
<body>
    <h1>Simple Task Manager - C++ Code</h1>
    <pre><code>
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;fstream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;ctime&gt;
using namespace std;

class Task {
private:
    string description;
    bool done;
public:
    Task(const string&amp; des) : description(des), done(false) {}
    string getDes(){ return description; }
    bool isDone(){ return done; }
    void StatusDone(){ done = true; }
};

class TaskM {
private:
    vector&lt;Task&gt; tasks;
    string filename="tasks.txt";
    void savefile(){
        ofstream outFile(filename);
        if(!outFile){
            cout &lt;&lt; "Couldn't Save Task Files " &lt;&lt; endl;
            return;
        }
        for(auto&amp; task : tasks){
            outFile &lt;&lt; task.getDes() &lt;&lt; "|" &lt;&lt; (task.isDone() ? "1" : "0") &lt;&lt; endl;
        }
        outFile.close();
    }

    void loadfile() {
        ifstream inFile(filename);
        if(!inFile) return;
        tasks.clear();
        string line;
        while (getline(inFile, line)) {
            auto parseLine= [](const string&amp; l) -&gt; pair&lt;string, bool&gt; {
                size_t delimPos = l.find('|');
                if(delimPos == string::npos) return {"", false};
                string desc= l.substr(0, delimPos);
                string statusStr = l.substr(delimPos + 1);
                statusStr.erase(statusStr.find_last_not_of(" \n\r\t") + 1);
                bool completed = (statusStr == "1");
                return {desc, completed};
            };
            auto [desc, completed]= parseLine(line);
            if(desc.empty()) continue;
            Task task(desc);
            tasks.emplace_back(desc);
            if(completed) tasks.back().StatusDone();
        }
    }   

public:
    TaskM(){ loadfile(); }
    void addTask(const string&amp; des){
        if(des.empty()){
            cout &lt;&lt; "Error!! Task description cannot be empty" &lt;&lt; endl;
            return;
        }
        tasks.emplace_back(des);
        savefile();
        cout &lt;&lt; "Task added successfully" &lt;&lt; endl;
    }

    void completeTask(size_t index){
        if(index &gt;= tasks.size()){
            cout &lt;&lt; "Error! Invalid task number" &lt;&lt; endl;
            return;
        }
        if(tasks[index].isDone()){
            cout &lt;&lt; "Task is already completed!" &lt;&lt; endl; 
        } else {
            tasks[index].StatusDone();
            savefile();
            cout &lt;&lt; "Task marked as completed." &lt;&lt; endl; 
        }
    }

    void displayTasks(){
        if(tasks.empty()){
            cout &lt;&lt; "No tasks available " &lt;&lt; endl;
            return;
        }
        cout &lt;&lt; "\nYour Tasks: " &lt;&lt; endl;
        for(size_t i=0; i &lt; tasks.size(); ++i){
            cout &lt;&lt; i + 1 &lt;&lt; "<< " &lt;&lt; tasks[i].getDes() 
                 &lt;&lt; " (" &lt;&lt; (tasks[i].isDone() ? "Completed" : "â—‹ Pending") &lt;&lt; ")" &lt;&lt; endl;
        }
        cout &lt;&lt; "   \n";
    }
};

int main() {
    TaskM manager;
    string input;
    
    cout &lt;&lt; "Simple Task Manager " &lt;&lt; endl;
    
    while (true) {
        cout &lt;&lt; "\nOptions: " &lt;&lt; endl;
        cout &lt;&lt; "1. Add Task : " &lt;&lt; endl; 
        cout &lt;&lt; "2. Complete Task: " &lt;&lt; endl;
        cout &lt;&lt; "3. Show All Tasks: " &lt;&lt; endl; 
        cout &lt;&lt; "4. Exit " &lt;&lt; endl; 
        cout &lt;&lt; "Choose an option (1-4)= " &lt;&lt; endl;
        getline(cin, input);

        if(input == "1") {
            cout &lt;&lt; "Enter task that you shall do: ";
            getline(cin, input);
            input.erase(0, input.find_first_not_of(" \t"));
            input.erase(input.find_last_not_of(" \t") + 1);
            if(input.empty()){
                cout &lt;&lt; "Error! Task description cannot be empty." &lt;&lt; endl;
                continue; 
            }
            manager.addTask(input);
        } else if(input == "2") {
            manager.displayTasks();
            cout &lt;&lt; "Enter task number to complete: ";
            getline(cin, input);    
            try {
                size_t index = stoul(input) - 1;
                manager.completeTask(index);
            } catch(const exception&amp; ) {
                cout &lt;&lt; "Error!! << Please enter a valid number " &lt;&lt; endl; 
            }
        } else if (input == "3") {
            manager.displayTasks();
        } else if (input == "4") {
            cout &lt;&lt; "Goodbye" &lt;&lt; endl;
            break;
        } else{
            cout &lt;&lt; "Invalid option!! Please choose 1-4" &lt;&lt; endl;
        }
    }
    return 0;
}
    </code></pre>
</body>
</html>
